pub const FRAME_WIDTH: usize = 256;
pub const FRAME_HEIGHT: usize = 240;

const PIXEL_SIZE: usize = 4;
const FRAME_BUFFER_SIZE: usize = FRAME_WIDTH * FRAME_HEIGHT * PIXEL_SIZE;

pub struct Screen {
    frame_buffer: Vec<u8>,
    draw_requested: bool
}

impl Screen {
    pub fn new() -> Self {
        Self {
            frame_buffer: vec![0; FRAME_BUFFER_SIZE],
            draw_requested: false
        }
    }

    pub fn get_frame_buffer(&mut self) -> &[u8] {
        &self.frame_buffer
    }

    pub fn set_pixel(&mut self, row: usize, column: usize, color: u8) {
        const R: [u8; 0x40] = [0x54, 0x00, 0x08, 0x30, 0x44, 0x5c, 0x54, 0x3c,
                               0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                               0x98, 0x08, 0x30, 0x5c, 0x88, 0xa0, 0x98, 0x78,
                               0x54, 0x28, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
                               0xec, 0x4c, 0x78, 0xb0, 0xe4, 0xec, 0xec, 0xd4,
                               0xa0, 0x74, 0x4c, 0x38, 0x38, 0x3c, 0x00, 0x00,
                               0xec, 0xa8, 0xbc, 0xd4, 0xec, 0xec, 0xec, 0xe4,
                               0xcc, 0xb4, 0xa8, 0x98, 0xa0, 0xa0, 0x00, 0x00];

        const G: [u8; 0x40] = [0x54, 0x1e, 0x10, 0x00, 0x00, 0x00, 0x04, 0x18,
                               0x2a, 0x3a, 0x40, 0x3c, 0x32, 0x00, 0x00, 0x00,
                               0x96, 0x4c, 0x32, 0x1e, 0x14, 0x14, 0x22, 0x3c,
                               0x5a, 0x72, 0x7c, 0x76, 0x66, 0x00, 0x00, 0x00,
                               0xee, 0x9a, 0x7c, 0x62, 0x54, 0x58, 0x6a, 0x88,
                               0xaa, 0xc4, 0xd0, 0xcc, 0xb4, 0x3c, 0x00, 0x00,
                               0xee, 0xcc, 0xbc, 0xb2, 0xae, 0xae, 0xb4, 0xc4,
                               0xd2, 0xde, 0xe2, 0xe2, 0xd6, 0xa2, 0x00, 0x00];

        const B: [u8; 0x40] = [0x54, 0x74, 0x90, 0x88, 0x64, 0x30, 0x00, 0x00,
                               0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00,
                               0x98, 0xc4, 0xec, 0xe4, 0xb0, 0x64, 0x20, 0x00,
                               0x00, 0x00, 0x00, 0x28, 0x78, 0x00, 0x00, 0x00,
                               0xec, 0xec, 0xec, 0xec, 0xec, 0xb4, 0x64, 0x20,
                               0x00, 0x00, 0x20, 0x6c, 0xcc, 0x3c, 0x00, 0x00,
                               0xec, 0xec, 0xec, 0xec, 0xec, 0xd4, 0xb0, 0x90,
                               0x78, 0x78, 0x90, 0xb4, 0xe4, 0xa0, 0x00, 0x00];
                               
        let offset = (row * FRAME_WIDTH + column) * PIXEL_SIZE;
        self.frame_buffer[offset + 0] = R[color as usize];
        self.frame_buffer[offset + 1] = G[color as usize];
        self.frame_buffer[offset + 2] = B[color as usize];
        self.frame_buffer[offset + 3] = 0xff; // A
    }

    pub fn is_draw_requested(&self) -> bool {
        self.draw_requested
    }

    pub fn request_draw(&mut self) {
        self.draw_requested = true;
    }

    pub fn finish_draw(&mut self) {
        self.draw_requested = false;
    }
}
